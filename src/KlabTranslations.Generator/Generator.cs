using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace KlabTranslations.Generator;

/// <summary>
/// Source generator for translation units.
/// </summary>
[Generator]
public class Generator : IIncrementalGenerator
{
    /// <inheritdoc/>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find only the file named "Translations.csv"
        IncrementalValuesProvider<AdditionalText> csvFiles = context
            .AdditionalTextsProvider
            .Where(file => file.Path.EndsWith("Translations.csv"));

        // Parse CSV file
        IncrementalValuesProvider<TranslationData?> translationData = csvFiles.Select((file, cancellationToken) =>
        {
            string? content = file.GetText(cancellationToken)?.ToString();
            if (string.IsNullOrEmpty(content))
            {
                return null;
            }

            return ParseCsv(content!);
        });

        // Generate code
        context.RegisterSourceOutput(translationData.Combine(context.CompilationProvider), (spc, combined) =>
        {
            (TranslationData? data, Compilation compilation) = combined;
            if (data == null)
            {
                return;
            }

            // Use the assembly name as the root namespace, or fall back to a default
            string rootNamespace = compilation.AssemblyName ?? "GeneratedTranslations";

            string source = GenerateTranslationClass(rootNamespace, data);
            spc.AddSource("Translations.g.cs", SourceText.From(source, Encoding.UTF8));
        });
    }

    private static string GenerateTranslationClass(string rootNamespace, TranslationData data)
    {
        StringBuilder sb = new();

        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine();
        sb.AppendLine($"namespace {rootNamespace}.Translations;");

        // Generate constants for keys
        sb.AppendLine("public static class Strings");
        sb.AppendLine("{");

        foreach (TranslationEntry entry in data.Translations)
        {
            StringBuilder translationDictSb = new();
            translationDictSb.AppendLine("new Dictionary<string, string>()");
            translationDictSb.AppendLine("        {");
            foreach (KeyValuePair<string, string> kvp in entry.Translations)
            {
                translationDictSb.AppendLine($"            [\"{kvp.Key}\"] = \"{kvp.Value.Replace("\"", "\\\"")}\",");
            }

            translationDictSb.Append("        }");
            sb.AppendLine($"    public static KlabTranslations.Core.TranslationUnit {entry.Key} =>");
            sb.AppendLine($"        new(\"{entry.Key}\", {translationDictSb});");
            sb.AppendLine();
        }

        sb.AppendLine("}");

        return sb.ToString();
    }

    private static TranslationData ParseCsv(string content)
    {
        List<string> lines = [.. content.Split('\n')
            .Select(line => line.Trim('\r', '\n'))
            .Where(line => !string.IsNullOrWhiteSpace(line))];

        if (lines.Count < 2)
        {
            throw new InvalidDataException("CSV content must have at least a header and one data row.");
        }

        // First line is the header (Key, de, en, etc.)
        List<string> headers = ParseCsvLine(lines[0]);

        // Extract language columns (skip the first "Key" column)
        List<string> languages = headers.Skip(1).ToList();

        List<TranslationEntry> entries = [];

        // Parse data rows (beginning from the second line)
        for (int i = 1; i < lines.Count; i++)
        {
            List<string> values = ParseCsvLine(lines[i]);
            if (values.Count < 1)
            {
                continue;
            }

            string key = values[0];
            Dictionary<string, string> translations = [];

            for (int j = 1; j < values.Count && j < headers.Count; j++)
            {
                string language = headers[j];
                string translation = values[j];
                translations[language] = translation;
            }

            entries.Add(new TranslationEntry(key, translations));
        }

        return new TranslationData(languages, entries);
    }

    private static List<string> ParseCsvLine(string line)
    {
        List<string> values = [];
        StringBuilder currentValue = new();
        bool insideQuotes = false;

        for (int i = 0; i < line.Length; i++)
        {
            char c = line[i];

            if (c == '"')
            {
                insideQuotes = !insideQuotes;
            }
            else if (c == ',' && !insideQuotes)
            {
                values.Add(currentValue.ToString().Trim());
                currentValue.Clear();
            }
            else
            {
                currentValue.Append(c);
            }
        }

        values.Add(currentValue.ToString().Trim());
        return values;
    }

    private sealed class TranslationData
    {
        public List<string> Languages { get; }
        public List<TranslationEntry> Translations { get; }

        public TranslationData(List<string> languages, List<TranslationEntry> entries)
        {
            Languages = languages;
            Translations = entries;
        }
    }

    private sealed class TranslationEntry
    {
        public string Key { get; }
        public Dictionary<string, string> Translations { get; }

        public TranslationEntry(string key, Dictionary<string, string> translations)
        {
            Key = key;
            Translations = translations;
        }
    }
}
